/* eslint-disable @typescript-eslint/no-require-imports */
const fs = require("fs");
const path = require("path");

const STATES = [
  { id: "MG", name: "Minas Gerais" },
  { id: "GO", name: "Goiás" },
  { id: "SP", name: "São Paulo" },
  { id: "MS", name: "Mato Grosso do Sul" },
];

const stations = [
  { lat: -19.8612, lon: -49.7689 },
  { lat: -19.3088, lon: -48.9276 },
  { lat: -20.1119, lon: -49.232 },
  { lat: -20.0303, lon: -48.9356 },
  { lat: -19.8710175519, lon: -48.6554272745 },
  { lat: -20.1417355955, lon: -48.7038773682 },
  { lat: -20.0183, lon: -48.9517 },
];

const sourceFile = path.join(__dirname, "..", "public", "brazil-states.geojson");
const targetFile = path.join(__dirname, "..", "data", "geo", "trianguloMapData.ts");

const ensureDir = (dir) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
};

const json = JSON.parse(fs.readFileSync(sourceFile, "utf8"));

const simplify = (points, toleranceDeg = 0.02) => {
  if (points.length <= 4) return points;
  const tolerance = toleranceDeg * toleranceDeg;

  const sqSegDist = (p, a, b) => {
    let x = a[1];
    let y = a[0];
    let dx = b[1] - x;
    let dy = b[0] - y;

    if (dx !== 0 || dy !== 0) {
      const t = ((p[1] - x) * dx + (p[0] - y) * dy) / (dx * dx + dy * dy);
      if (t > 1) {
        x = b[1];
        y = b[0];
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    const dxp = p[1] - x;
    const dyp = p[0] - y;
    return dxp * dxp + dyp * dyp;
  };

  const simplifyDP = (start, end, keep) => {
    const stack = [[start, end]];

    while (stack.length) {
      const [s, e] = stack.pop();
      let maxDist = 0;
      let index = -1;

      for (let i = s + 1; i < e; i += 1) {
        const dist = sqSegDist(points[i], points[s], points[e]);
        if (dist > maxDist) {
          index = i;
          maxDist = dist;
        }
      }

      if (maxDist > tolerance && index !== -1) {
        keep[index] = true;
        stack.push([s, index], [index, e]);
      }
    }
  };

  const keep = new Array(points.length).fill(false);
  keep[0] = true;
  keep[points.length - 1] = true;
  simplifyDP(0, points.length - 1, keep);

  const simplified = [];
  for (let i = 0; i < points.length; i += 1) {
    if (keep[i]) simplified.push(points[i]);
  }
  return simplified;
};

const multiPolygonToLatLon = (geometry) => {
  const polygons = [];
  const coords = geometry.coordinates || [];
  coords.forEach((poly) => {
    if (!poly.length) return;
    const outer = poly[0];
    const latLon = outer.map(([lon, lat]) => [lat, lon]);
    const cleaned = latLon.filter((pt, idx) => !(idx > 0 && pt[0] === latLon[idx - 1][0] && pt[1] === latLon[idx - 1][1]));
    const closed = cleaned[0][0] === cleaned[cleaned.length - 1][0] && cleaned[0][1] === cleaned[cleaned.length - 1][1]
      ? cleaned.slice(0, -1)
      : cleaned;
    polygons.push(simplify(closed));
  });
  return polygons;
};

const features = json.features.filter((feature) => {
  const name = feature.properties && (feature.properties.name || feature.properties.NAME_1 || feature.properties.estado);
  return STATES.some((state) => state.name === name);
});

const bounds = { latMin: Infinity, latMax: -Infinity, lonMin: Infinity, lonMax: -Infinity };

const statePolygons = features.map((feature) => {
  const name = feature.properties && (feature.properties.name || feature.properties.NAME_1 || feature.properties.estado);
  const state = STATES.find((s) => s.name === name);
  const polygons = multiPolygonToLatLon(feature.geometry);
  polygons.forEach((polygon) => {
    polygon.forEach(([lat, lon]) => {
      bounds.latMin = Math.min(bounds.latMin, lat);
      bounds.latMax = Math.max(bounds.latMax, lat);
      bounds.lonMin = Math.min(bounds.lonMin, lon);
      bounds.lonMax = Math.max(bounds.lonMax, lon);
    });
  });
  return { id: state ? state.id : name, name, polygons };
});

const hull = (() => {
  const pts = stations.map((s) => ({ lon: s.lon, lat: s.lat })).sort((a, b) => (a.lon === b.lon ? a.lat - b.lat : a.lon - b.lon));
  const build = (list) => {
    const stack = [];
    list.forEach((pt) => {
      while (stack.length >= 2) {
        const [b, a] = [stack[stack.length - 1], stack[stack.length - 2]];
        if ((b.lon - a.lon) * (pt.lat - a.lat) - (b.lat - a.lat) * (pt.lon - a.lon) <= 0) {
          stack.pop();
        } else {
          break;
        }
      }
      stack.push(pt);
    });
    return stack;
  };
  const lower = build(pts);
  const upper = build(pts.slice().reverse());
  upper.pop();
  lower.pop();
  return lower.concat(upper).map((p) => [p.lat, p.lon]);
})();

const dataDir = path.join(__dirname, "..", "data", "geo");
ensureDir(dataDir);

const header = `// Auto-generated by scripts/build-triangulo-map.js\n// Contains simplified polygons for Triângulo Mineiro context map\n\nexport type LatLon = [number, number];\n\nexport interface RegionState {\n  id: string;\n  name: string;\n  polygons: LatLon[][];\n}\n\nexport const TRIANGULO_STATES: RegionState[] = ${JSON.stringify(statePolygons, null, 2)} as const;\n\nexport const TRIANGULO_HULL: LatLon[] = ${JSON.stringify(hull, null, 2)} as const;\n\nexport const TRIANGULO_BOUNDS = ${JSON.stringify(bounds, null, 2)} as const;\n`;

fs.writeFileSync(targetFile, header);
console.log(`Wrote ${targetFile}`);
